// This file is automatically generated. Do not edit it directly.
//
// Locally, we *do* add small runtime hardening because Supabase Auth's
// Navigator Lock acquisition can sometimes time out during dev/HMR or when a
// previous tab/instance is stuck, causing an unhandled AbortError and leaving
// the app in a perpetual "loading" state.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL as string | undefined;
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY as string | undefined;

function requireEnv(value: string | undefined, name: string): string {
  if (!value) {
    throw new Error(`[Supabase] Missing ${name}. Check your .env and restart the dev server.`);
  }
  return value;
}

type AuthLockFn = <R>(name: string, acquireTimeout: number, fn: () => Promise<R>) => Promise<R>;

function isAbortError(e: unknown): e is { name: string } {
  if (typeof e !== 'object' || e === null) return false;
  if (!('name' in e)) return false;
  return (e as { name?: unknown }).name === 'AbortError';
}

const resilientNavigatorLock: AuthLockFn = async (name, acquireTimeout, fn) => {
  const locks: LockManager | undefined = typeof navigator !== 'undefined' ? navigator.locks : undefined;
  if (!locks?.request) return await fn();

  // Some environments (extensions/proxies/buggy LockManager impls) can cause
  // navigator.locks.request() to never resolve/reject. Ensure we never block
  // auth flows forever by racing it with a timeout and running `fn()` at most once.
  if (acquireTimeout <= 0) {
    return await locks.request(name, { mode: 'exclusive', ifAvailable: true }, async (lock) => {
      if (!lock) return await fn();
      return await fn();
    });
  }

  const abortController = new globalThis.AbortController();
  let timeoutId: number | undefined;
  let ran = false;

  const fallbackPromise = new Promise<Awaited<ReturnType<typeof fn>>>((resolve, reject) => {
    timeoutId = window.setTimeout(() => {
      if (ran) return;
      ran = true;

      try {
        abortController.abort();
      } catch {
        // ignore
      }

      console.warn(
        `[Supabase] Auth lock acquire timed out after ${acquireTimeout}ms for "${name}". ` +
          `Proceeding without lock to avoid blocking auth flow.`
      );

      fn().then(resolve, reject);
    }, acquireTimeout);
  });

  const requestPromise = locks
    .request(name, { mode: 'exclusive', signal: abortController.signal }, async (lock) => {
      if (ran) return undefined as unknown as Awaited<ReturnType<typeof fn>>;
      ran = true;
      if (timeoutId !== undefined) window.clearTimeout(timeoutId);

      // Some browsers have returned null even when ifAvailable isn't set.
      // In that case, run the function anyway for backward compatibility.
      if (!lock) return await fn();
      return await fn();
    })
    .catch(async (e: unknown) => {
      if (ran) return undefined as unknown as Awaited<ReturnType<typeof fn>>;

      // If the lock request aborts early, just continue without the lock.
      if (isAbortError(e)) {
        ran = true;
        if (timeoutId !== undefined) window.clearTimeout(timeoutId);
        return await fn();
      }

      throw e;
    });

  try {
    return await Promise.race([requestPromise, fallbackPromise]);
  } finally {
    if (timeoutId !== undefined) window.clearTimeout(timeoutId);
  }
};

function createSupabaseClient() {
  const url = requireEnv(SUPABASE_URL, 'VITE_SUPABASE_URL');
  const key = requireEnv(SUPABASE_PUBLISHABLE_KEY, 'VITE_SUPABASE_PUBLISHABLE_KEY');

  // Keep this as a separate variable so we can pass extra GoTrue options
  // (like lockAcquireTimeout) without fighting excess-property checks.
  const authOptions = {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
    // 크게 줄여서 빠르게 탈출하도록 함. 여러 탭/HMR 환경에서 lock 획득 실패 시 즉시 진행.
    lockAcquireTimeout: 5_000,
    lock: resilientNavigatorLock,
    // URL에서 세션 감지를 비활성화하여 초기화 속도 향상
    detectSessionInUrl: false,
  };

  return createClient<Database>(url, key, {
    auth: authOptions,
  });
}

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Make the client resilient to Vite HMR by keeping a single instance per page.
type TypedSupabaseClient = ReturnType<typeof createSupabaseClient>;
const globalForSupabase = globalThis as unknown as { __supabase__?: TypedSupabaseClient };
export const supabase = globalForSupabase.__supabase__ ?? (globalForSupabase.__supabase__ = createSupabaseClient());
